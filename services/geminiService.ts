import { GoogleGenAI, Modality, Part } from "@google/genai";

if (!process.env.API_KEY) {
  throw new Error("API key is not configured. Please set the API_KEY environment variable.");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const IDENTITY_INSTRUCTION = "Use the original face/subject of upload file, 100% unchanged.";

/**
 * Converts a Data URL string to an InlineDataPart for the Gemini API.
 */
const dataURLtoFilePart = (dataUrl: string): Part => {
  const parts = dataUrl.split(';base64,');
  const mimeType = parts[0].split(':')[1];
  const base64Data = parts[1];
  return {
    inlineData: {
      mimeType,
      data: base64Data,
    },
  };
};

/**
 * Generates a single image using the Gemini API.
 */
async function generateSingleImage(prompt: string, imageParts: Part[], aspectRatio: string): Promise<string> {
  const fullPrompt = `${prompt} The image should have a ${aspectRatio} aspect ratio.`;
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts: [...imageParts, { text: fullPrompt }] },
      config: {
        responseModalities: [Modality.IMAGE],
      },
    });

    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData) {
        const base64ImageBytes: string = part.inlineData.data;
        return `data:image/png;base64,${base64ImageBytes}`;
      }
    }
    throw new Error('No image was generated by the API.');
  } catch (error) {
    console.error("Error generating single image with Gemini:", error);
    if (error instanceof Error) {
        throw new Error(`Failed to generate image: ${error.message}`);
    }
    throw new Error('An unknown error occurred during single image generation.');
  }
}

/**
 * Generates images from a list of poses and/or angles.
 */
export async function generateFromPosesAndAngles(payload: any): Promise<{url: string, meta: any}[]> {
  const { selected_poses, selected_angles, custom_prompt, use_custom_only, identity_instruction, source_image, aspect_ratio } = payload;

  let itemsToGenerate = [...(selected_poses || []), ...(selected_angles || [])];
  
  if (custom_prompt && use_custom_only) {
      itemsToGenerate = ['Custom Prompt'];
  } else if (itemsToGenerate.length === 0 && custom_prompt) {
      itemsToGenerate = ['Custom Prompt'];
  }

  if (itemsToGenerate.length === 0) {
    throw new Error("Please select at least one pose/angle or provide a custom prompt.");
  }

  const imageParts: Part[] = [];
  if (source_image) {
    imageParts.push(dataURLtoFilePart(source_image));
  }

  const generationPromises = itemsToGenerate.map(itemLabel => {
    let prompt;
    if (custom_prompt && (use_custom_only || itemLabel === 'Custom Prompt')) {
        prompt = custom_prompt;
    } else {
        prompt = `A photorealistic image of a person. Pose/Angle: "${itemLabel}".`;
        if (custom_prompt) {
            prompt += ` Style/Details: "${custom_prompt}"`;
        }
    }
    prompt += ` ${identity_instruction || IDENTITY_INSTRUCTION}`;
    const metaLabel = (use_custom_only || itemLabel === 'Custom Prompt') ? 'Custom Prompt' : itemLabel;
    return generateSingleImage(prompt, imageParts, aspect_ratio).then(url => ({ url, meta: { label: metaLabel } }));
  });

  return Promise.all(generationPromises);
}


/**
 * Constructs a detailed prompt string from the product interaction parameters.
 */
function buildProductInteractionPrompt(interaction: any): string {
    if (!interaction) return "";

    const { action, hand, placement, distance, scale_percent, rotation_deg, occlusion } = interaction;
    let prompt = " The subject should interact with the product (the third reference image).";
    
    prompt += ` The primary action is to '${action}'.`;

    if (hand && hand !== 'auto') {
        prompt += ` Use the ${hand} hand(s) for this action.`;
    }
    if (placement && placement !== 'auto') {
        prompt += ` Place the product at the '${placement}' position relative to the subject.`;
    }
    if (distance) {
        prompt += ` The product should be at a '${distance}' distance from the viewer.`;
    }
    if (scale_percent && scale_percent !== 100) {
        prompt += ` The product's scale should be adjusted to ${scale_percent}% of its reference size.`;
    }
    if (rotation_deg && rotation_deg !== 0) {
        prompt += ` The product should be rotated by ${rotation_deg} degrees.`;
    }
    if (occlusion && occlusion !== 'auto') {
        prompt += ` When positioning, ${occlusion} occlusion of the product by the subject's hands or body.`;
    }
    
    return prompt;
}


/**
 * Generates images by combining a face and an outfit, with optional poses/angles.
 */
export async function generateFromOutfit(payload: any): Promise<{url: string, meta: any}[]> {
    const { face_reference, outfit_reference, product_reference, product_interaction, selected_poses, selected_angles, identity_instruction, aspect_ratio, background_mode, studio_background, outfit_extraction, custom_prompt, use_custom_only } = payload;
    
    if (!face_reference || !outfit_reference) {
        throw new Error("Face and Outfit references are required.");
    }
    
    const imageParts: Part[] = [
        dataURLtoFilePart(face_reference),
        dataURLtoFilePart(outfit_reference)
    ];

    if (product_reference) {
        imageParts.push(dataURLtoFilePart(product_reference));
    }

    let itemsToGenerate = [...(selected_poses || []), ...(selected_angles || [])];
    
    if (custom_prompt && use_custom_only) {
      itemsToGenerate = ['Custom Prompt'];
    } else if (itemsToGenerate.length === 0) {
      itemsToGenerate.push("Default pose");
    }


    const generationPromises = itemsToGenerate.map(itemLabel => {
        let basePrompt;
        if (custom_prompt && (use_custom_only || itemLabel === 'Custom Prompt')) {
            basePrompt = custom_prompt;
        } else {
            basePrompt = `Combine the face from the first image with the outfit/object from the second image. Pose/Angle: "${itemLabel}".`;
            if (custom_prompt) {
                basePrompt += ` Style/Details: "${custom_prompt}"`;
            }
        }
        
        let prompt = `${basePrompt} ${identity_instruction || IDENTITY_INSTRUCTION}`;

        if (outfit_extraction === 'auto') {
            prompt += ' The second image contains a model wearing the outfit; please intelligently extract just the outfit and apply it to the subject from the first image.';
        }

        if (product_reference && product_interaction) {
            prompt += buildProductInteractionPrompt(product_interaction);
        }

        if (background_mode === 'solid' && studio_background) {
            prompt += ` The background should be a solid color: ${studio_background}.`;
        } else if (background_mode === 'transparent') {
            prompt += ' The background should be transparent (alpha channel).';
        } else { // 'keep' or default
            prompt += ' Preserve the original background from the reference images as much as possible.';
        }
        
        const metaLabel = (use_custom_only || itemLabel === 'Custom Prompt') ? 'Custom Prompt' : itemLabel;
        return generateSingleImage(prompt, imageParts, aspect_ratio).then(url => ({ url, meta: { label: metaLabel }}));
    });

    return Promise.all(generationPromises);
}


/**
 * Simple storyboard parser. Assumes one scene description per line.
 * Handles both LF and CRLF line endings.
 */
const parseStoryboard = (content: string): { label: string, description: string }[] => {
    return content.split(/\r?\n/) // Use regex to handle different line endings
        .map(line => line.trim())
        .filter(line => line.length > 0)
        .map((line, index) => ({
            label: `Scene ${index + 1}`,
            description: line
        }));
};

/**
 * Generates a storyboard from a text file and optional reference images.
 */
export async function generateFromStoryboard(payload: any): Promise<{url: string, meta: any}[]> {
    const { storyboard_file, face_reference, outfit_reference, identity_instruction, aspect_ratio, custom_prompt } = payload;

    if (!storyboard_file || !storyboard_file.content) {
        throw new Error("Storyboard file content is missing.");
    }

    const scenes = parseStoryboard(storyboard_file.content);
    if (scenes.length === 0) {
        throw new Error("Storyboard file is empty or invalid.");
    }

    const imageParts: Part[] = [];
    if (face_reference) {
        imageParts.push(dataURLtoFilePart(face_reference));
    }
    if (outfit_reference) {
        imageParts.push(dataURLtoFilePart(outfit_reference));
    }

    const generationPromises = scenes.map(scene => {
        let prompt = `Storyboard Scene: ${scene.description}.`;
        if (custom_prompt) {
            prompt += ` Overall Style/Instructions: "${custom_prompt}"`;
        }
        prompt += ` ${identity_instruction || IDENTITY_INSTRUCTION}`;
        return generateSingleImage(prompt, imageParts, aspect_ratio).then(url => ({ url, meta: { label: scene.label }}));
    });

    return Promise.all(generationPromises);
}